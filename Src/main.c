/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include "sensor_Data_Classifier.h"
#include "plant_profile.h"
#include "time_stamped_state_data.h"
#include "notification.h"
#include "sys_tick.h"
#include "uart.h"


/*SW delay */
void delay()
{
	for(volatile uint32_t i = 0; i < 100000; ++i);
}

int main(void)
{
	__vo uint16_t index  = 0;
	__vo Occurence_count_Struct plant_state_pattern_count[PLANTS];

	/* ToDo: To enable printf using UART protocol over GPIO PIN 2 */
	/* GPIO Alternate Functionality Initiation*/
	GPIO_Handle_Struct gpio_uart;

	gpio_uart.pGpio = GPIOA;
	gpio_uart.gpio_user_cfg.pin_number  = GPIO_PIN_2;
	gpio_uart.gpio_user_cfg.pin_mode    = GPIO_ALT_FUNC_MODE;
	gpio_uart.gpio_user_cfg.pin_otype   = GPIO_PIN_PUSH_PULL;
	gpio_uart.gpio_user_cfg.pin_ospeed  = GPIO_HIGH_SPEED;

	gpio_init(&gpio_uart);

	/* USART Initialization */
	USART_RegDef_Struct *usart = USART2;
    usart_init(usart);

    /* For Sensor data Range Calculation */
	const char* Sensor_data_current_status[] = {"LOW","MODERATE","HIGH","VERY HIGH"};

	/* Loop forever */
	while(1)
	{
	  /* Looping over total number of indoor plants available */
	  for(uint8_t plant_id=0;plant_id < PLANTS;plant_id++)
	  {
          /*To set the index to zero once it reaches the max records */
		  if(index >= MAX_RECORDS)
		  {
			  index  = 0;
		  }

		  /* systick counter is activated and it will increment the "systick_timer" to 1 second on each loop */
		  extern __vo uint32_t systick_timer;
		  delay_ms(1000);

          /* structure instance declaration */
		  Sensor_data_Struct sensor_data;
		  Current_time_Struct cur_time_data;

          /* API for fetching the simulated sensor data */
		  sensor_data_plant(plant_id, &sensor_data);

		  uint8_t soil_moisture_data      = sensor_data.moisture_data;
		  uint8_t room_tempearture_data   = sensor_data.temp_data;
		  uint16_t room_light_data        = sensor_data.light_data;


		  /* Classifying the range for the fetched simulated sensor data */
		  const char* moisture_current_state = Sensor_data_current_status[state_classifier_8_bit(plant_profile_db[plant_id].moisture_thresholds,soil_moisture_data)];
		  const char* temp_current_state     = Sensor_data_current_status[state_classifier_8_bit(plant_profile_db[plant_id].temp_thresholds, room_tempearture_data)];
		  const char* light_current_state    = Sensor_data_current_status[state_classifier_16_bit(plant_profile_db[plant_id].light_intensity_thresholds, room_light_data)];

		  /* For generating the current time on each loop */
          log_current_time(&cur_time_data,systick_timer);
          uint8_t hours   = cur_time_data.hour;
          uint8_t minutes = cur_time_data.minute;
          uint8_t seconds = cur_time_data.second;

          /* Logging plant id and classified simulated data in to an array of structure */
          time_stamped_db[index].time_stamped_plant_id  = plant_id;
          time_stamped_db[index].time_stamped_hour      = hours;
          time_stamped_db[index].time_stamped_min       = minutes;
          time_stamped_db[index].time_stamped_sec       = seconds;
          time_stamped_db[index].total_time_in_sec      = ((hours*3600) + (minutes*60)+ seconds);

          /* Used strcpy as this way only strings can be compared */
          strcpy(time_stamped_db[index].time_stamped_moist_state,moisture_current_state);
          strcpy(time_stamped_db[index].time_stamped_temp_state,temp_current_state);
          strcpy(time_stamped_db[index].time_stamped_light_state,light_current_state);

          /* Condition to check current plant profile
           * (sensor data/current profile condition of the plant) in the specified time window.
           * This is part of the adaptive pattern learning.
          */
          if(index == MAX_RECORDS-1)
          {
            /* API to check current plant profile based on history or pattern within a time window */
        	print_time_stamped_data(time_stamped_db,&plant_state_pattern_count[PLANTS]);

        	/* API to Trigger notification if occurrence/pattern matching counter exceeds a certain threshold
        	 *
        	*/
            trigger_notification(&plant_state_pattern_count[PLANTS]);
          }

          /* index increment after completing the current loop condition*/
          index++;

	  }

	}
}
